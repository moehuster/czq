多进程：
	＊fork()复制当前进程（整个进程空间），新旧进程的差别在于pid不同。
	新旧进程都从fork的最后一个语句开始继续执行。
	＊新旧进程id不一定连续！系统在用完id之后，会重用那些已经不用的id。
	＊新旧进程执行的先后顺序不确定，完全由系统调度进程来决定。
	＊只要父进程（旧进程）结束，shell就认为进程已经结束，从而接管终端，
	显示命令提示符，接受并解释用户输入的命令，而不管子进程（新进程）
	是否还在运行。
	＊进程结束：main函数返回；调用exit/_exit/_Exit；调用abort；接收到
	特殊的信号（比方说Ctrl+C，kill命令）
	系统会回收进程id，回收进程内存空间，释放进程的控制结构；关闭打开的
	文件描述符，执行atexit登记的退出处理函数。
	*atexit(func)用来登记需要在程序结束时调用的函数(无参无返回值的函数),
	一般用这种机制来实现在程序结束做一些必要的清理工作。可以登记多个，
	执行时按跟登记相反的顺序执行。main函数返回或者调用exit，退出处理函
	数会正常执行，其它几种方式结束进程时，退出处理函数不执行。
	*fork克隆完毕时在新进程里放的函数的返回值为0，而在旧进程里面放的函
	数的返回值为新进程的id。因此，到return语句时在两个进程中的返回值是
	不同的。在父进程中返回的是子进程id，在子进程里返回的是0。如果失败，
	在父进程里返回-1，没有子进程。
	＊调用fork的进程本身称为父进程，克隆出来的进程称为原进程的子进程。
	＊打开的文件描述符也会克隆，双方不要同时写同一个文件。
	system与fork的区别：system会等待新进程结束才继续执行旧进程，fork产
	生的新旧进程互不等待。system执行另一个命令，fork是把本进程克隆。
	execv也可以用来执行一个可执行文件。它就在调用它的进程里执行新可执行
	文件，不产生新进程，而是霸占了当前进程，新的可执行文件从头开始执行，
	原进程中的代码全部被覆盖。除非这个函数失败，否则不会返回。
	char*argv[];
	execv(带路径的可执行文件名,argv[])其中argv[0]跟带路径的可执行文件名
	应该一致。如果不一致，后果不确定。从argv[1]开始就是后续的参数字符串，
	最后一个元素设置成NULL作为数组结束标志。
	
	作业：写一个程序，克隆出三个子进程，第一个用execv加载程序aa,第二个
	用execv加载程序bb,第三个用execv加载程序cc,然后自己退出，但aa,bb,cc
	还继续运行。写一个程序，可执行文件名为aa，每秒在屏幕上打一个"陈"字。
	写一个程序，可执行文件名为bb，每秒在屏幕上打一个"宗"字。写一个程序，
	可执行文件名为cc，每秒在屏幕上打一个"权"字。在屏幕上打字用write(1,.
	..,strlen(...))
	
	ps
	kill 进程id
=====================================================================

	char*argv[];
	execv(带路径的可执行文件名,argv[])其中argv[0]跟带路径的可执行文件名应该
	一致。如果不一致，后果不确定。从argv[1]开始就是后续的参数字符串，最后一
	个元素设置成NULL作为数组结束标志。其中argv是传递给新程序的main函数的第二
	个参数。

	
	pid1 = fork();
	pid2 = fork();
	child1:pid1==0,pid2>0
	child2:pid1>0,pid2==0
	grand3:pid1==0,pid2==0
	parent:pid1>0,pid2>0

	＊execvp用法跟execv一样，不同在于，如果可执行文件没有带路径，它会通过
	环境变量PATH去查找可执行文件。
	execl(带路径的可执行文件名,后面依次摆放argv的各个元素)，注意最后一个是
	NULL。功能跟execv相同。注意，正常情况下，传递给execl的前两个参数（可执
	行文件名和argv[0]）应该相同。
	＊execlp用法跟execl一样，不同在于，如果可执行文件没有带路径，它会通过环
	境变量PATH去查找可执行文件。
	execve/execle用法跟execvp/execlp相同，不同在于会在调用的时候在其它参数
	全部写完之后，再传一个环境变量数组char*env[],对应main函数的第三种格式。
	极少使用。
	
	exec系列函数总是跟fork配合使用，在fork产生的子进程中调用exec系列函数之
	一。vfork可以替代fork，创建一个新进程作为旧进程的子进程，但它不克隆，节
	省时间。因为没有克隆，所以新进程暂时在旧进程空间执行，旧进程会等待新进程
	执行，直到执行调用exec系列函数之一或者结束，旧进程才继续。vfork之后exec之
	前不要修改任何变量的值(除了取得vfork的返回值)。vfork的返回值跟fork一样。
	1.system("ps > a.txt")
	atoi
	char kill[100];
	sprintf(kill,"kill %d", id);
	system(kill);
	2.fork, write(...id...)
	read,
	char kill[100];
	sprintf(kill,"kill %d", id);
	system(kill);
	3.fork,fprintf(fp,"kill %d\n",id);
	char kill[100];
	fgets(kill,sizeof(kill),...)
	system(kill);
	
作业：在昨天的基础上，改用vfork,改用命令行参数来传递要打的文字，三次都加载
同一个程序。再写一个程序，运行时终止那些在屏幕上打字的子进程，让屏幕恢复正常。
